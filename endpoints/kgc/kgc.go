package kgc

import (
	"encoding/base64"
	"fmt"
	"hash"
	"math/big"
	"os"
	"path/filepath"
	"strings"

	"github.com/emmansun/gmsm/sm3"
	"github.com/pelletier/go-toml/v2"

	"github.com/OpenNHP/opennhp/endpoints/kgc/curve"
)

type Config struct {
	MasterPrivateKeyBase64 string `json:"masterPrivateKeyBase64"`
	MasterPublicKeyBase64  string `json:"masterPublicKeyBase64"`
	DefaultCipherScheme    int    `json:"defaultCipherScheme"`
}

type MasterKey struct {
	Ms    *big.Int // Master private key in KGC, KGC SHOULD keep its safety
	PpubX *big.Int // X coordinate of master public key in KGC
	PpubY *big.Int // Y coordinate of master public key in KGC
}

func (m MasterKey) String() string {
	return fmt.Sprintf("MasterKey{Ms: %x, PpubX: %x, PpubY: %x}", m.Ms.Bytes(), m.PpubX.Bytes(), m.PpubY.Bytes())
}

type KGCUserPartialKey struct {
	Id string
	T  *big.Int // User partial private key which is generated by KGC
	Wx *big.Int // X coordinate of User declared public key
	Wy *big.Int // Y coordinate of User declared public key
}

type KGC interface {
	Params() *curve.CurveParams
	GenerateMasterKey() error
	GenerateUserPartialKey(userId string, userPartialPubX *big.Int, userPartialPubY *big.Int) (*KGCUserPartialKey, error)
}

type KGCImpl struct {
	curve.Curve
	h         hash.Hash
	masterKey *MasterKey
}

func (k *KGCImpl) Params() *curve.CurveParams {
	return k.Params()
}

// GenerateMasterKey generates a new master key pair (private and public) for the KGC (Key Generation Center).
// It creates a random master secret (Ms), derives the public key (Ppub) from it using elliptic curve multiplication,
// and updates both keys in the system's config file (config.toml) as base64-encoded strings.
// Returns an error if any step fails (random number generation, file operations, etc.).
func (k *KGCImpl) GenerateMasterKey() error {
	ms, err := GenerateRandomNumber(k.Params().N)
	if err != nil {
		return err
	}

	masterKey := MasterKey{
		Ms: ms,
	}

	masterKey.PpubX, masterKey.PpubY = k.ScalarBaseMult(masterKey.Ms.Bytes())

	k.masterKey = &masterKey

	updateValueWithKey := func(content, key, value string) string {
		lines := strings.Split(content, "\n")
		for i, line := range lines {
			if strings.HasPrefix(line, key) {
				lines[i] = fmt.Sprintf("%s = \"%s\"", key, value)
			}
		}

		return strings.Join(lines, "\n")
	}

	// Also update it to the config file
	dirPath, err := GetExeDirPath()
	if err != nil {
		return err
	}

	configFilePath := filepath.Join(dirPath, "etc", "config.toml")
	content, err := os.ReadFile(configFilePath)
	if err != nil {
		return err
	}

	content = []byte(updateValueWithKey(string(content), "MasterPrivateKeyBase64", base64.StdEncoding.EncodeToString(ms.Bytes())))
	pubKeyBytes := masterKey.PpubX.Bytes()
	pubKeyBytes = append(pubKeyBytes, masterKey.PpubY.Bytes()...)
	content = []byte(updateValueWithKey(string(content), "MasterPublicKeyBase64", base64.StdEncoding.EncodeToString(pubKeyBytes)))

	err = os.WriteFile(configFilePath, content, 0644)
	if err != nil {
		return err
	}

	return nil
}

// GenerateKGCUserPartialKey generates a partial key for the specified user using elliptic curve cryptography.
// It takes the user ID and their partial public key coordinates (x,y) as input, and returns a KGCUserPartialKey
// containing the generated components (T, Wx, Wy) or an error if key generation fails.
// The function combines system parameters, master key, and user information to compute the partial key.
func (k *KGCImpl) GenerateKGCUserPartialKey(userId string, userPartialPubX *big.Int, userPartialPubY *big.Int) (*KGCUserPartialKey, error) {
	info := []byte{}
	lenUserId := len(userId)
	info = append(info, byte(lenUserId>>8))
	info = append(info, byte(lenUserId))
	info = append(info, []byte(userId)...)
	info = append(info, k.Params().A.Bytes()...)
	info = append(info, k.Params().B.Bytes()...)
	info = append(info, k.Params().Gx.Bytes()...)
	info = append(info, k.Params().Gy.Bytes()...)
	info = append(info, k.masterKey.PpubX.Bytes()...)
	info = append(info, k.masterKey.PpubY.Bytes()...)

	k.h.Write(info)
	infoHash := k.h.Sum(nil)
	k.h.Reset()

	w, err := GenerateRandomNumber(k.Params().N)
	if err != nil {
		return nil, err
	}

	wx, wy := k.ScalarBaseMult(w.Bytes())

	declaredUserPubX, declaredUserPubY := k.Add(wx, wy, userPartialPubX, userPartialPubY)

	lamdaInfo := []byte{}
	lamdaInfo = append(lamdaInfo, declaredUserPubX.Bytes()...)
	lamdaInfo = append(lamdaInfo, declaredUserPubY.Bytes()...)
	lamdaInfo = append(lamdaInfo, infoHash...)

	k.h.Write(lamdaInfo)
	lamdaHash := k.h.Sum(nil)
	k.h.Reset()
	lamda := new(big.Int).SetBytes(lamdaHash)
	lamda.Mod(lamda, k.Params().N)

	t := new(big.Int).Add(w, new(big.Int).Mul(lamda, k.masterKey.Ms))
	t.Mod(t, k.Params().N)

	return &KGCUserPartialKey{
		Id: userId,
		T:  t,
		Wx: declaredUserPubX,
		Wy: declaredUserPubY,
	}, nil
}

func (k *KGCImpl) GetHash() hash.Hash {
	return k.h
}

func (k *KGCImpl) GetMasterKey() *MasterKey {
	return k.masterKey
}

type KGCEllipticCurveMode uint8

const (
	SM2 KGCEllipticCurveMode = iota
	UNKNOWN
)

func (k KGCEllipticCurveMode) String() string {
	switch k {
	case SM2:
		return "SM2"
	default:
		return "UNKNOWN"
	}
}

func (k KGCEllipticCurveMode) NewKGCImpl() *KGCImpl {
	switch k {
	case SM2:
		curve := curve.NewOfficialSM2Curve()
		// curve := curve.NewCustomSM2Curve()

		kgcImpl := &KGCImpl{
			Curve: curve,
		}

		kgcImpl.h = sm3.New()

		return kgcImpl
	default:
		return nil
	}
}

// NewKGCImplFromConfig creates a new KGCImpl instance by loading and parsing the configuration file.
// It reads the config.toml file from the etc directory relative to the executable's path,
// decodes the base64-encoded master keys, and initializes the KGC implementation.
// Returns an error if the config file is missing, invalid, or if the master keys are not set.
func NewKGCImplFromConfig() (*KGCImpl, error) {
	dirPath, err := GetExeDirPath()
	if err != nil {
		return nil, err
	}

	configFilePath := filepath.Join(dirPath, "etc", "config.toml")
	content, err := os.ReadFile(configFilePath)
	if err != nil {
		return nil, err
	}

	var config Config
	if err := toml.Unmarshal(content, &config); err != nil {
		return nil, err
	}

	if config.MasterPrivateKeyBase64 == "" || config.MasterPublicKeyBase64 == "" {
		return nil, fmt.Errorf("master key is not set, please execuute setup command first")
	}

	masterPrivateKey, err := base64.StdEncoding.DecodeString(config.MasterPrivateKeyBase64)
	if err != nil {
		return nil, err
	}

	masterPublicKey, err := base64.StdEncoding.DecodeString(config.MasterPublicKeyBase64)
	if err != nil {
		return nil, err
	}

	if config.DefaultCipherScheme == 0 {
		k := SM2.NewKGCImpl()
		k.masterKey = &MasterKey{
			Ms:    new(big.Int).SetBytes(masterPrivateKey),
			PpubX: new(big.Int).SetBytes(masterPublicKey[0:32]),
			PpubY: new(big.Int).SetBytes(masterPublicKey[32:]),
		}
		return k, nil
	} else {
		return nil, fmt.Errorf("not support default cipher scheme %d", config.DefaultCipherScheme)
	}
}
